Parallel Solvers
================

This is a collection of parallel solvers for hard problems. These are primarily
aimed at ``really hard'' instances, i.e. there are no sparseness restrictions,
and there are probably better (or at least much less memory-intensive)
solutions if your data is sparse.

This is for ``work in progress'' code and experimentation. If you'd like to use
this code in a real project, you'll need to rip it out. In other words, this
isn't a nice friendly library.

You will need a C++11 compiler, such as GCC 4.7, to compile this. You will also
need Boost.

We use boilermake for compilation:

    https://github.com/dmoulding/boilermake

By default, compiled programs go in "build/$HOSTNAME/". You can override this,
for example, by doing:

    make TARGET_DIR=./

The solvers are as follows:

solve_max_clique
----------------

This solves the maximum clique problem.

To run, do 'solve_max_clique algorithm filename.clq' where filename.clq is in
the DIMACS format, and algorithm is one of "naive mcsa1 tmcsa1 bmcsa1 tbmcsa1".
The 't' is for threaded, the 'b' is for bitset encoding, and for 'mcsa1' refer
to Prosser's 2012 "Exact Algorithms for Maximum Clique: A Computational Study".
There are various options, use 'solve_max_clique --help' to list them.

The output is as follows:

    size_of_max_clique number_of_search_nodes
    witness
    runtimes

Where the first runtime is the overall time (excluding reading in the graph) in
steady-clock ms, and any additional values are per-thread runtimes.

If work donation is enabled, a fourth line will show how many times this
happened. If a timeout is specified, the first line will also say 'aborted'.

solve_max_biclique
------------------

This solves the maximum biclique problem.

Right now the code only handles balanced, induced bicliques in an arbitrary
graph.

To run, do 'solve_max_biclique algorithm filename.clq' where filename.clq is
in the DIMACS format, and algorithm is one of "naive cc". There are various
options, use 'solve_max_biclique --help' to list them.

The output is:

    size_of_max_biclique number_of_search_nodes
    witness_a
    witness_b
    runtimes

solve_roommates
---------------

This solves the stable roommates problem (which is not actually hard).

solve_balanced_pairs
--------------------

Generates all pairs of sets (a, b) where a and b are disjoint, have the same
cardinality, and whose elements are drawn from 1..n. The point is to illustrate
the symmetry breaking used in max_biclique: if --break-ab-symmetry is
specified, all unordered pairs are generated (i.e. if (a, b) is generated, (b,
a) is not).

create_random_graph
-------------------

Creates an Erdos-Reyni random graph. Usage is 'create_random_graph n p s'
where n is the number of vertices, p is the edge probability (between 0.0 and
1.0), and s is the seed (an integer). Specifying the same seed will produce the
same output each time, avoiding the need for storing large graph files.

To avoid writing to a temp file, bash lets you do this:

    solve_max_clique bmcsa1 <(create_random_graph 100 0.5 1)

create_random_bipartite_graph
-----------------------------

Creates a random bipartite graph. Usage is 'create_random_bipartite_graph n1
n2 p s' where n1 is the number of vertices in the first set, n2 is the number
of vertices in the second set, p is the edge probability (between 0.0 and 1.0),
and s is the seed (an integer). Specifying the same seed will produce the same
output each time, avoiding the need for storing large graph files.

To avoid writing to a temp file, bash lets you do this:

    solve_max_biclique naive <(create_random_bipartite_graph 20 20 0.5 1)

.. vim: set ft=plain spell spelllang=en ft=text :

